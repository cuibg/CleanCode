# OOP规约

1. 避免通过一个类的对象引用访问此类的静态变量或静态方法，无谓增加编译器解析成本，直接用类名来访问即可。
2. 所有的覆写方法，必须加@Override 注解。
3. 相同参数类型，相同业务含义，才可以使用 Java 的可变参数，避免使用 Object。可变参数必须放到最后一个参数，而且不提倡使用可变参数
4. 外部正在调用或者二方库依赖的接口，不允许修改方法签名，避免对接口调用方产生影响。接口过时必须加@Deprecated 注解，并清晰地说明采用的新接口或者新服务是什么。
5. 不能使用过时的类或方法。
6. Object 的 equals 方法容易抛空指针异常，应使用常量或确定有值的对象来调用equals。
7. 所有的相同类型的包装类对象之间值的比较，全部使用 equals 方法比较。
8. 构造方法里面禁止加入任何业务逻辑，如果有初始化逻辑，请放在 init 方法中。
9. 使用索引访问用 String 的 split 方法得到的数组时，需做最后一个分隔符后有无内容的检查，否则会有抛 IndexOutOfBoundsException 的风险。
10. 当一个类有多个构造方法，或者多个同名方法，这些方法应该按顺序放置在一起，便于阅读.
11. 类内方法定义的顺序依次是：公有方法或保护方法 > 私有方法 > getter/setter方法。
12. setter 方法中，参数名称与类成员变量名称一致，this.成员名 = 参数名。在getter/setter 方法中，不要增加业务逻辑，增加排查问题的难度。
13. 循环体内，字符串的连接方式，使用 StringBuilder 的 append 方法进行扩展。
14. final 可以声明类、成员变量、方法、以及本地变量，下列情况使用 final 关键字：

  * 不允许被继承的类，如：String 类。
  * 不允许修改引用的域对象，如：POJO 类的域变量。
  * 不允许被重写的方法，如：POJO 类的 setter 方法。
  * 不允许运行过程中重新赋值的局部变量。
  * 避免上下文重复使用一个变量，使用 final 描述可以强制重新定义一个变量，方便更好地进行重构。

15. 慎用 Object 的 clone 方法来拷贝对象
16. 类成员与方法访问控制从严：

  * 如果不允许外部直接通过 new 来创建对象，那么构造方法必须是 private。
  * 工具类不允许有 public 或 default 构造方法。
  * 类非 static 成员变量并且与子类共享，必须是 protected。
  * 类非 static 成员变量并且仅在本类使用，必须是 private。
  * 类 static 成员变量如果仅在本类使用，必须是 private。
  * 若是 static 成员变量，必须考虑是否为 final。
  * 类成员方法只供类内部调用，必须是 private。
  * 类成员方法只对继承类公开，那么限制为 protected。



